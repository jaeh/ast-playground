<!DOCTYPE html>@magic/core concepts{"@context":"http://schema.org","@type":"website","name":"@magic/core documentation","url":"https://magic.github.io/core","about":"@magic framework core.","image":"https://magic.github.io/core/logo.png","author":{"@type":"person","name":"Jascha Ehrenreich","jobTitle":"Technomancer","image":"https:/jaeh.at/img/jascha.ehrenreich.jpg","url":"https://jaeh.at"}}Skip to Content@magicconceptsmodulesstateactionsviewsstylesglobalserver lambdasfiles &amp; directoriesmodulesthemeslibrariesnews@magic/core conceptsmagic concepts. These are the building blocks of every module in a magic app@magic-modulesmodules are the main building block of magic.a page is a module, a button is a module, a link is a module, an image is a module.
even a theme is a module.a @magic app contains modules containing modules that contain modules.
this can lead to inception.module building blocksstatestate is a javascript object.
state can be mutated by actions, 
effects and subscriptions can call actions to change the state.
every rendering frame, the state determines the output of the html views.copyconst state = {  shown: false,  count: 0,}actionsactions are an object containing functionsthose functions get the state and their props and may return a new full, but changed, state.copyconst actions = {  toggleModal: state =&gt; {    return {      ...state,      shown: !state.shown,    }  },  calculator: {    plus: state =&gt; ({ ...state, count: state.count + 1 }),    minus: state =&gt; ({ ...state, count: state.count - 1 }),  },}effectseffects are an object containing functions, just like actions.effects can only change the state by calling actions.effects may also be impure and trigger side-effects outside of hyperapp.copyconst effects = {  waitASec: [state, async state =&gt; {    await new Promise((r) =&gt; setTimeout(r, 1000))    return actions.plus(state)  }],}subscriptionsat the moment, subscriptions can be defined using strings as function names.if a module exports a subscriptions array, those subscriptions will be added to the app.copyconst subscriptions = [  subscribe = (dispatch, action) =&gt; {    setInterval(() =&gt; {      dispatch(action, { arg: Math.random() * 100 })    })  }]const actions = {  onSubscription: (state, e) =&gt; ({    ...state,    arg: e.arg,  })}export const subscriptions = [&#39;subscriptions.subscribe&#39;, &#39;actions.onSubscription&#39;]viewsviews render the state to html
whenever an action triggers a change in the state, this then triggers a view change.copyexport const View = state =&gt; div(JSON.stringify(state))stylesevery module can export a style object.
magic will automagically merge all styles into one global css file.
in the future, it will also remove unused styles for you.styles merge order, last overwrites first:
module.style &lt; page.style &lt; app.style &lt; theme.stylethis allows css to be inherited in both directions.a module automatically creates it&#39;s own css namespace,
that same namespace can be used in page, app and theme css styles 
to overwrite module specific styles.@magic/cssinternally, magic uses it&#39;s own css-in-js library.to find out more, click the following link:
@magic/cssglobalsevery module can set a global object, containing state and action properties.every state and/or action name in the global object with a value that equals true gets merged into the main app state/actions, instead of into the module namespace.copy// in module.mjsexport const state = {  internal: 0,  external: 0,}export const actions = {  internal: state =&gt; ({    ...state,    module: {      internal: state.module.interal + 1,    },  }),  external: state =&gt; ({    ...state,    external: state.external + 1,  }),}export const global = {  state: {    external: true  },  actions: {    external: true,  },}// in the view, we can use both the global and local actions and state variablesexport const View = state =&gt; div([  &#39;view&#39;,  p({ onclick: actions.module.internal }, [&#39;internal:&#39;, state.module.internal]),  p({ onclick: actions.external }, [&#39;external:&#39;, state.external]),])server lambdasthis is the serverside magic.
you can define functions that get transpiled into serverside lambdas.
server side lambdas will be available for GET and/or POST requests.the server side function signature is (req, res) =&gt; {},
as it is in most nodejs http servers,
with the addition of req.body being async =&gt; awaited before execution of the lambda.made with a few bits of magic